Python 3.13, Kubernetes, and Vault â€“ SSL Troubles & Fixes
With Python 3.13 enforcing VERIFY_X509_STRICT by default, both the Python Kubernetes client and Vault encountered SSL verification failures due to certificate issues. Hereâ€™s how I resolved them.

Issue Summary
ğŸ”¹ Kubernetes (MicroK8s 1.32.3)
- The default CA certificate generated by MicroK8s lacks the required attribute:
keyUsage=critical,digitalSignature,keyCertSign
- This causes Python-Kubernetes API calls to fail spectacularly ğŸ’¥
- Solution: Regenerate the CA cert with proper key usage extensions
ğŸ”¹ Vault (1.19.4)
- Python 3.13 enforces stricter SSL validation, requiring an RFC 5280-compliant CA cert
- Vault requires at least one IP-based SAN in its TLS certificate for proper authentication
- Solution: Ensure Vault certs include both the keyUsage extension and an IP-based SAN

Step 1: Fixing MicroK8s CA Certificate
If youâ€™re setting up a fresh MicroK8s cluster, run this right after installing the snap:
cd /var/snap/microk8s/current/certs
mkdir cadir
openssl genrsa -out cadir/ca.key 2048
openssl req -x509 -new -nodes -key ca.key -sha256 -days 360 -out cadir/ca.crt -addext "keyUsage=critical,digitalSignature,keyCertSign"
microk8s refresh-certs cadir  # [Original Post](https://github.com/canonical/microk8s/issues/4864)

î·™î·š
If modifying an existing multi-node cluster, additional steps are required:
1ï¸âƒ£ Prep for Certificate Update
- Designate one node as the â€˜primeâ€™
- On each remaining node:
kubectl taint nodes <node1> <node2> key=value:NoSchedule
kubectl drain lboost cboost --ignore-daemonsets --delete-emptydir-data
microk8s leave
- Remove nodes from the cluster:
microk8s remove-node <node1>
microk8s remove-node <node2>


2ï¸âƒ£ Apply New CA Certificate
Run the CA certificate update from step 1 on the â€˜primeâ€™ node.
3ï¸âƒ£ Restart & Rejoin Nodes
- Restart MicroK8s with the new certificate:
microk8s stop && microk8s start
- Re-add the nodes back to the cluster:
microk8s add-node



Step 2: Fixing Vault SSL Certificates
Vaultâ€™s authentication fails unless its TLS certificate includes an IP-based SAN.
Hereâ€™s how I generated a valid cert:
1ï¸âƒ£ Create OpenSSL Config File (openssl.cnf)
[ v3_req ]
keyUsage = critical, digitalSignature, keyEncipherment
subjectAltName = IP:192.168.86.60, IP:127.0.0.1


2ï¸âƒ£ Generate & Sign Certificates
openssl genpkey -algorithm RSA -out vault.key
openssl req -new -key vault.key -out vault.csr -subj "/CN=vault-server" -addext "subjectAltName=IP:192.168.86.60,IP:127.0.0.1,DNS:vault.local"
openssl x509 -req -in vault.csr -CA ca.crt -CAkey ca.key -CAcreateserial -out vault.crt -days 365 -sha256 -extfile openssl.cnf -extensions v3_req

î·™î·š
3ï¸âƒ£ Verify Certificate Includes Correct SANs
openssl x509 -in vault.crt -text -noout


4ï¸âƒ£ Update Vault Config to Use New Cert
Modify vault.hcl:
listener "tcp" {
  address = "0.0.0.0:8200"
  tls_cert_file = "/etc/vault/certs/vault.crt"
  tls_key_file  = "/etc/vault/certs/vault.key"
}


Restart Vault:
systemctl restart vault



Step 3: Streamlining the Process
I streamlined everything by using the MicroK8s CA to generate Vaultâ€™s certs instead of managing two separate CAs.
This ensures consistent compliance across services.
So far, itâ€™s working wellâ€”but time will tell!

Bonus: Common Confusion
ğŸ”¹ IP-based SAN â‰  IP-based Storage Area Network ğŸ˜†
Turns out, they are completely unrelatedâ€”lesson learned!

Final Thoughts
This setup has eliminated Python 3.13 SSL errors, restored Kubernetes API functionality, and made Vault authentication work again.
Hope this helps anyone running into similar issues! ğŸš€

Let me know if you want additional tweaks or formatting changes! ğŸ”¥
This documentation is already greatâ€”just making it extra polished so itâ€™s easier for future reference. ğŸ—ï¸
What do you think? ğŸš€
